import { openDB, DBSchema, IDBPDatabase } from 'idb';
import { db as firestoreDB, isFirebaseEnabled } from '../lib/firebase';
import { collection, getDocs, setDoc, doc, deleteDoc, updateDoc } from 'firebase/firestore';
import { Project, Donation, Expense, VolunteerApplication, Document } from '../types';

interface AkhundianDB extends DBSchema {
  projects: { key: string; value: Project };
  donations: { key: string; value: Donation };
  expenses: { key: string; value: Expense };
  volunteers: { key: string; value: VolunteerApplication };
  documents: { key: string; value: Document };
}

type AkhundianStoreName = 'projects' | 'donations' | 'expenses' | 'volunteers' | 'documents';

const DB_NAME = 'akhundian-internal-db';
const DB_VERSION = 1;

let dbPromise: Promise<IDBPDatabase<AkhundianDB>>;

// --- INTERNAL DB HELPERS (IndexedDB - Fallback) ---
export const initInternalDB = () => {
  if (!dbPromise) {
    dbPromise = openDB<AkhundianDB>(DB_NAME, DB_VERSION, {
      upgrade(db) {
        ['projects', 'donations', 'expenses', 'volunteers', 'documents'].forEach(store => {
          if (!db.objectStoreNames.contains(store as AkhundianStoreName)) {
            db.createObjectStore(store as AkhundianStoreName, { keyPath: 'id' });
          }
        });
      },
    });
  }
  return dbPromise;
};

// --- HYBRID SERVICE (Firebase + IndexedDB) ---
export const dbService = {
  async getAll<K extends AkhundianStoreName>(storeName: K): Promise<AkhundianDB[K]['value'][]> {
    if (isFirebaseEnabled && firestoreDB) {
      try {
        const querySnapshot = await getDocs(collection(firestoreDB, storeName));
        return querySnapshot.docs.map(doc => doc.data() as AkhundianDB[K]['value']);
      } catch (error) {
        console.error(`Firebase load error for ${storeName}:`, error);
        return [];
      }
    }
    // Fallback to Internal DB
    const db = await initInternalDB();
    return db.getAll(storeName);
  },

  async add<K extends AkhundianStoreName>(storeName: K, value: AkhundianDB[K]['value']): Promise<void> {
    if (isFirebaseEnabled && firestoreDB) {
      try {
        // Use setDoc to preserve the ID generated by the frontend
        await setDoc(doc(firestoreDB, storeName, (value as any).id), value);
        return;
      } catch (error) {
        console.error(`Firebase add error for ${storeName}:`, error);
      }
    }
    const db = await initInternalDB();
    await db.put(storeName, value);
  },

  async update<K extends AkhundianStoreName>(storeName: K, value: AkhundianDB[K]['value']): Promise<void> {
    if (isFirebaseEnabled && firestoreDB) {
      try {
        await updateDoc(doc(firestoreDB, storeName, (value as any).id), value as any);
        return;
      } catch (error) {
        console.error(`Firebase update error for ${storeName}:`, error);
      }
    }
    const db = await initInternalDB();
    await db.put(storeName, value);
  },

  async delete<K extends AkhundianStoreName>(storeName: K, id: string): Promise<void> {
    if (isFirebaseEnabled && firestoreDB) {
      try {
        await deleteDoc(doc(firestoreDB, storeName, id));
        return;
      } catch (error) {
        console.error(`Firebase delete error for ${storeName}:`, error);
      }
    }
    const db = await initInternalDB();
    await db.delete(storeName, id);
  },
  
  async clear<K extends AkhundianStoreName>(storeName: K): Promise<void> {
      if (!isFirebaseEnabled) {
        const db = await initInternalDB();
        await db.clear(storeName);
      }
  }
};